//
// GLMath - MatInits.swift
//
// Initializers for matrix types.
//
// Copyright (c) 2016 The GLMath authors.
// Licensed under MIT License.

// NOTE:
// - Do NOT edit this file. Edit file `MatInits.swift.gyb` instead.

#if !os(Linux)

import simd

% for (tp, col, row) in [(t, c, r) for t in {"Float", "Double"} for c in {2, 3, 4} for r in {2, 3, 4}]:
%   args = ["_ m{0}{1}: {2}".format(r, c, tp) for c in xrange(1, col + 1) for r in xrange(1, row + 1)]
%   vecs = []
%   for c in xrange (1, col + 1):
%       initargs = ", ".join(["m{0}{1}".format(r, c) for r in xrange(1, row + 1)])
%       vecs.append("{0}{1}({2})".format(tp.lower(), row, initargs))
%   end
extension ${tp.lower()}${col}x${row} {

    public init (
        ${", ".join(args)}
    ) {
        self.init(
            ${", ".join(vecs)}
        )
    }
}

% end
#else

% for (col, row) in [(c, r) for c in {2, 3, 4} for r in {2, 3, 4}]:
%   args = []
%   if col == row:
%       args = ["_ m{0}{1}: T".format(r, c) for c in xrange(1, col + 1) for r in xrange(1, row + 1)]
%   else:
%       args = ["_ m{0}{1}: T.Component".format(r, c) for c in xrange(1, col + 1) for r in xrange(1, row + 1)]
%   end
%   vecs = []
%   for c in xrange (1, col + 1):
%       initargs = ", ".join(["m{0}{1}".format(r, c) for r in xrange(1, row + 1)])
%       if col == row:
%           vecs.append("Vec{0}<T>({1})".format(row, initargs))
%       else:
%           vecs.append("T({1})".format(row, initargs))
%       end
%   end
%   if col == row:
extension Mat${col}x${row} {
%   else:
extension Mat${col} where T: FloatVector${row} {
%   end

    public init (
        ${", ".join(args)}
    ) {
        self.init(
            ${", ".join(vecs)}
        )
    }
}

% end
#endif
